skip_docs

# iOS Specific Constants
IOS_PROJECT = File.join(IOS_PATH, "TrezorSuite.xcodeproj").freeze
IOS_PROJECT_WORKSPACE = File.join(IOS_PATH, "TrezorSuite.xcworkspace").freeze

platform :ios do

  before_all do |lane|
    puts "Running lane #{lane}..."

    # setup a temporary keychain
    setup_ci

    if lane == :develop
      PROVISIONING_NAME = "AppStore io.trezor.suite.develop"
    elsif lane == :staging
      PROVISIONING_NAME = "AppStore io.trezor.suite.staging"
    elsif lane == :production
      PROVISIONING_NAME = "AppStore io.trezor.suite"
    end
  end

  desc "Load Appstore Connect API Key information to use in subsequent lanes"
  private_lane :load_appstore_connect_api_key do |options|
    app_store_connect_api_key(
      key_id: ENV['APPSTORE_KEY_ID'], # the Key ID used for Appstore Connect authentication
      issuer_id: ENV['APPSTORE_KEY_ISSUER_ID'], # the issuer ID used for Appstore Connect authentication
      key_content: ENV['APPSTORE_KEY_FILE_CONTENT'], # the base64-encoded private key (.p8) used for Appstore Connect authentication
      is_key_content_base64: true,
      duration: 1200,
      in_house: false
    )
  end

  desc "Check certs and profiles"
  private_lane :prepare_signing do |options|
    app_identifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
    api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]

    # path and password are set by setup_ci (https://github.com/fastlane/fastlane/blob/master/fastlane/lib/fastlane/actions/setup_ci.rb)
    cert(
      api_key: api_key,
      keychain_path: "~/Library/Keychains/#{ENV["MATCH_KEYCHAIN_NAME"]}",
      keychain_password: ENV["MATCH_KEYCHAIN_PASSWORD"]
    )

    sigh(
      api_key: api_key,
      app_identifier: app_identifier,
      provisioning_name: PROVISIONING_NAME,
      force: true # always recreate this exact profile to ensure it's valid and not expired
    )
  end

  desc "Increments internal build number and version number"
  private_lane :fetch_and_bump_versions do |options|
    app_identifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
    api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]

    previous_build_number = latest_testflight_build_number(
      app_identifier: app_identifier,
      api_key: api_key
    )

    increment_build_number(
      xcodeproj: IOS_PROJECT,
      build_number: previous_build_number + 1
    )
    increment_version_number(
      xcodeproj: IOS_PROJECT,
      version_number: VERSION
    )
  end

  desc "Build the iOS app for testing"
  private_lane :build_testing do |options|
    build_scheme = options[:scheme]
    app_identifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)

   # update the code signing identities to match profile name and app bundle identifier
   update_code_signing_settings(
     use_automatic_signing: false, # turn off automatic signing during build so correct code signing identity is guaranteed to be used
     targets: ["TrezorSuite"],
     code_sign_identity: "iPhone Distribution",
     bundle_identifier: app_identifier,
     profile_name: PROVISIONING_NAME,
     build_configurations: [build_scheme], # only toggle code signing settings for Release configurations
     path: IOS_PROJECT
   )

    build_app(
      scheme: build_scheme,
      output_name: "#{build_scheme}-TrezorSuite",
      workspace: IOS_PROJECT_WORKSPACE,
      configuration: build_scheme
    )
  end

  desc "Upload to TestFlight"
  private_lane :upload_testing do |options|
    api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]

    upload_to_testflight(
        api_key: api_key,
        changelog: CHANGELOG
    )
  end

  desc "Push a new beta build to TestFlight"
  private_lane :testing do |options|
    load_appstore_connect_api_key
    prepare_signing
    fetch_and_bump_versions
    build_testing(options[:scheme])
    upload_testing
  end

  lane :develop do
    testing(scheme: "Develop")
  end
  lane :staging do
    testing(scheme: "Staging")
  end
  lane :production do
    # TODO
    # sth(scheme: "Release", provisioning_name: "AppStore io.trezor.suite"))
  end

  after_all do |lane|
    # This block is called, only if the executed lane was successful

    # slack(
    #   message: "Successfully deployed new App Update."
    # )
  end

  error do |lane, exception|
    # slack(
    #   message: exception.message,
    #   success: false
    # )
  end
end
